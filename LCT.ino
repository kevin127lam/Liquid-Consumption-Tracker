#include "arduino_secrets.h"
#include <Adafruit_SSD1306.h>
#include <splash.h>
#include <Adafruit_GFX.h>
#include <Adafruit_GrayOLED.h>
#include <Adafruit_SPITFT.h>
#include <Adafruit_SPITFT_Macros.h>
#include <gfxfont.h>
#include "arduino_secrets.h"
#include <Arduino_LSM6DS3.h>
#include <Wire.h>

#define SCREEN_WIDTH 128 // OLED display width, in pixels
#define SCREEN_HEIGHT 64 // OLED display height, in pixels
#define PI 3.1415926535897932384626433832795

// Declaration for an SSD1306 display connected to I2C (SDA, SCL pins)
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, -1);

/* 
  Sketch generated by the Arduino IoT Cloud Thing "Untitled"
  https://create.arduino.cc/cloud/things/223699f5-cc5e-4021-b5b5-1cb1eafb4be5 

  Arduino IoT Cloud Variables description

  The following variables are automatically generated and updated when changes are made to the Thing

  float amountConsumed;
  float consumptionGoal;
  float distance;
  float goalPercent;
  float volume;
  bool goalReached;
  bool halfGoal;
  bool quarterGoal;
  bool threeQGoal;

  Variables which are marked as READ/WRITE in the Cloud Thing will also have functions
  which are called when their values are changed from the Dashboard.
  These functions are generated with the Thing and added at the end of this sketch.
*/

#include "thingProperties.h"

// Array to store incoming serial data
unsigned char data_buffer[4] = {0};

// Variable to hold checksum
unsigned char CS;

// sample data to help reduce noise
const int numSamples = 100;
int samples[numSamples] = {0};
float previousVolume = 0.0;

void setup() {
  // Initialize serial and wait for port to open:
  Serial.begin(115200);
  // This delay gives the chance to wait for a Serial Monitor without blocking if none is found
  delay(1500); 

  // Defined in thingProperties.h
  initProperties();

  // Set up software serial port
  Serial1.begin(9600);

  if (!IMU.begin()) {
    Serial.println("Failed to initialize IMU!");

    while (1);
  }

  // Connect to Arduino IoT Cloud
  ArduinoCloud.begin(ArduinoIoTPreferredConnection);

  // set up the screen information
  if (!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) { // Address 0x3D for 128x64
    Serial.println(F("SSD1306 allocation failed"));
    for (;;);
  }
  delay(2000);
  display.clearDisplay();
  display.setTextSize(1);
  display.setTextColor(WHITE);
  
  /*
     The following function allows you to obtain more information
     related to the state of network and IoT Cloud connection and errors
     the higher number the more granular information youâ€™ll get.
     The default is 0 (only errors).
     Maximum is 4
 */
  setDebugMessageLevel(2);
  ArduinoCloud.printDebugInfo();
}

//print the volume values
void printValues(float distance, float volume, float amountConsumed, float percent) {
  // Print to Serial Monitor
  Serial.print("Volume: ");
  Serial.print(volume);
  Serial.print(" mL; ");
  
  Serial.print("Distance: ");
  Serial.print(distance);
  Serial.println(" mm ");


  // Update OLED display
  display.clearDisplay();
  display.setCursor(0, 10);
  display.print("Amount Consumed: ");
  display.print(amountConsumed);
  display.println(" mL");
  display.print("Percent of Goal: ");
  display.print(percent);
  display.println("%");
  display.display(); // Show the updated text
}


void loop() {
  ArduinoCloud.update();
  
  // Your code here 
  float x, y, z;

  // Read acceleration
  if (IMU.gyroscopeAvailable()) {
    IMU.readGyroscope(x, y, z);
  }
  if (isMoving(x)) {
    Serial.println("Bottle is moving");
    Serial1.end();
    Serial1.flush();
    delay(7500);
    // Set up software serial port
    Serial1.begin(9600);
    Serial1.flush();
  }

  if (Serial1.available() > 0) {
    delay(4);
    Serial1.flush();
    if (Serial1.read() == 0xff) {
      data_buffer[0] = 0xff;
      for (int i = 1; i < 4; i++) {
        data_buffer[i] = Serial1.read();
      }

      CS = data_buffer[0] + data_buffer[1] + data_buffer[2];
      if (data_buffer[3] == CS) {
        int tempDistance = (data_buffer[1] << 8) + data_buffer[2];
        for (int i = numSamples - 1; i > 0; i--) {
          samples[i] = samples[i - 1];
        }
        samples[0] = tempDistance;

        if (samples[numSamples - 1] > 0) {
          int sorted[numSamples];
          memcpy(sorted, samples, sizeof(samples));
  
          // Sort for median
          for (int i = 0; i < numSamples - 1; i++) {
            for (int j = i + 1; j < numSamples; j++) {
              if (sorted[j] < sorted[i]) {
                int temp = sorted[i];
                sorted[i] = sorted[j];
                sorted[j] = temp;
              }
            }
          }
          distance = sorted[numSamples / 2];
          volume = (1.0 / 3.0) * PI * (125 - distance) * ((40 * 40 + 25 * 25) + 40 * 25) / 1000.0;

          float volumeChange = previousVolume - volume;
          
          // Detect a legitimate decrease in volume (assume user drank)
          if (volumeChange > 1.0) { // threshold to ignore noise, adjust as needed
            amountConsumed += volumeChange;
          
            // Clamp to not exceed goal or go negative
            if (amountConsumed <= 0) {
              amountConsumed = 0;
              goalPercent = 0;
            }
            if (amountConsumed > consumptionGoal) amountConsumed = consumptionGoal;
          
            // Update goal percent
            goalPercent = (consumptionGoal > 0) ? (amountConsumed / consumptionGoal) * 100.0 : 0;

            if (goalPercent >= 100) {
              goalReached = true;
            } else if (goalPercent >= 75) {
              threeQGoal = true;
            } else if (goalPercent >= 50) {
              halfGoal = true;
            } else if (goalPercent >= 25) {
              quarterGoal = true;
            } else{
              goalReached = false;
              threeQGoal = false;
              halfGoal = false;
              quarterGoal = false;
            }
          }
          printValues(distance, volume, amountConsumed, goalPercent);
          previousVolume = volume;
        }
      }
    }
  }
}


int outOfBoundsCount = 0;  // Global counter for consecutive out-of-range readings
const int thresholdCount = 3;  // Require 3 in a row
float prevX = 0;

bool isMoving(float x) {
  if (x < -65) {
    outOfBoundsCount++;
  } else {
    outOfBoundsCount = 0;  // Reset if within range
  }

  // Check if any axis has changed from previous reading
  bool changed = (x != prevX);

  // Store current values for next comparison
  prevX = x;

  if ((outOfBoundsCount >= thresholdCount) && changed) {
    outOfBoundsCount = 0;  // Reset after triggering
    return true;
  }

  return false;
}

/*
  Since Volume is READ_WRITE variable, onVolumeChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onVolumeChange()  {
  // Add your code here to act upon Volume change
  //printValues(volume, distance);
}


/*
  Since ConsumptionGoal is READ_WRITE variable, onConsumptionGoalChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onConsumptionGoalChange()  {
  // Add your code here to act upon ConsumptionGoal change
}

/*
  Since AmountConsumed is READ_WRITE variable, onAmountConsumedChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onAmountConsumedChange()  {
  // Add your code here to act upon AmountConsumed change
}

/*
  Since GoalPercent is READ_WRITE variable, onGoalPercentChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onGoalPercentChange()  {
  // Add your code here to act upon GoalPercent change
}




/*
  Since GoalStatus is READ_WRITE variable, onGoalStatusChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onGoalStatusChange()  {
  // Add your code here to act upon GoalStatus change
}


/*
  Since QuarterGoal is READ_WRITE variable, onQuarterGoalChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onQuarterGoalChange()  {
  // Add your code here to act upon QuarterGoal change
}

/*
  Since HalfGoal is READ_WRITE variable, onHalfGoalChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onHalfGoalChange()  {
  // Add your code here to act upon HalfGoal change
}

/*
  Since ThreeQGoal is READ_WRITE variable, onThreeQGoalChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onThreeQGoalChange()  {
  // Add your code here to act upon ThreeQGoal change
}

/*
  Since GoalReached is READ_WRITE variable, onGoalReachedChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onGoalReachedChange()  {
  // Add your code here to act upon GoalReached change
}








